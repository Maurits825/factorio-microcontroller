#define MAX_LOOP_COUNT 400
#define PADDLE1_MOVE_RANGE 6
#define PADDLE2_MOVE_RANGE 25
#define PADDLE_LENGTH 5
#define HALF_PADDLE_LENGTH EVPY(PADDLE_LENGTH / 2)

VAR pos_x
VAR pos_y
MOVLW 28
MOVWF pos_x
MOVLW 16
MOVWF pos_y
VAR pos_x_y // for igpu args

VAR paddle1_pos_x
MOVLW 18
MOVWF paddle1_pos_x
VAR paddle1_line

VAR paddle2_pos_x
MOVLW 18
MOVWF paddle2_pos_x
VAR paddle2_line

// set velocity to right and top
VAR v_x
VAR v_y
MOVLW 2
MOVWF v_x
MOVWF v_y

// draw background in buffer 1
IGSETFL 1
IGDRAWRL EVPY((5 << 18) | (31 << 12) | (0 << 6) | (0))
IGDRAWRL EVPY((36 << 18) | (31 << 12) | ((36-5) << 6) | (0))
IGSETFL 0

VAR loop_count
// main loop ---------------------------------------------------------------
LABEL LOOP
IGCLEAR

// pack ball args
MOVFW pos_x
ROLWL,w 6
ORWF,w pos_y
MOVWF pos_x_y

// render ball
IGDRAWPF pos_x_y

// pack paddle1 args
MOVLW EVPY(PADDLE_LENGTH << 12)
MOVWF paddle1_line
MOVFW paddle1_pos_x
// sub half paddle length because x is middle of paddle
SUBWL,w HALF_PADDLE_LENGTH
ROLWL,w 6
ORWF,f paddle1_line

// render paddle1
IGDRAWHF paddle1_line

// pack paddle2 args
MOVLW EVPY((PADDLE_LENGTH << 12) | 31)
MOVWF paddle2_line
MOVFW paddle2_pos_x
// sub half paddle length because x is middle of paddle
SUBWL,w HALF_PADDLE_LENGTH
ROLWL,w 6
ORWF,f paddle2_line

// render paddle2
IGDRAWHF paddle2_line

IGRENDER

// main logic ---------------------------------------------------------------------

MOVFW pos_y
EQWL,0 0 // check if p1 lost
GOTO P2_WIN

EQWL,0 31 // check if p2 lost
GOTO P1_WIN

// check if pos x == 5 and set v_x to the right -> 2
MOVFW pos_x
EQWL,1 5
MOVLW 2
MOVWF v_x

// check if pos x == 36-5 and set v_x to the left -> 1
EQWL,1 30
MOVLW 1
MOVWF v_x

// check if pos y == 1
MOVFW pos_y
EQWL,8 1
//now check if paddle1 is under
MOVFW pos_x
SUBWF,w paddle1_pos_x
ADDWL,w HALF_PADDLE_LENGTH //half of paddle length
GRTWL,0 EVPY(PADDLE_LENGTH - 1) //check if right side of paddle
GOTO SKIP_P1_BOUNCE
LESSWL,0 0 //check if left side of paddle
GOTO SKIP_P1_BOUNCE

//paddle is under, set v_y to the top -> 2
MOVLW 2
MOVWF v_y

LABEL SKIP_P1_BOUNCE

//TODO could try make a func? pass paddle pos with W reg, return either 1 or 2 to set the velocity
MOVFW pos_y
EQWL,8 30
//now check if paddle1 is under
MOVFW pos_x
SUBWF,w paddle2_pos_x
ADDWL,w HALF_PADDLE_LENGTH //half of paddle length
GRTWL,0 EVPY(PADDLE_LENGTH - 1) //check if right side of paddle
GOTO SKIP_P2_BOUNCE
LESSWL,0 0 //check if left side of paddle
GOTO SKIP_P2_BOUNCE

//paddle is under, set v_y to the bottom -> 1
MOVLW 1
MOVWF v_y

LABEL SKIP_P2_BOUNCE

// double DECRF hack for x and y because its an if not if-else
// check v_x and update pos_x
MOVFW v_x
EQWL,1 1
DECRF pos_x
DECRF pos_x
INCRF pos_x

// check v_y and update pos_y
MOVFW v_y
EQWL,1 1
DECRF pos_y
DECRF pos_y
INCRF pos_y

// move paddle 1
// first check if ball is going down
MOVFW v_y
EQWL,0 2
GOTO SKIP_PADDLE1_MOVE
// check if its close
MOVFW pos_y
GRTWL,0 PADDLE1_MOVE_RANGE
GOTO SKIP_PADDLE1_MOVE
// check if paddle is already in place
MOVFW pos_x
EQWF,0 paddle1_pos_x
GOTO SKIP_PADDLE1_MOVE

// ball is close, move paddle1
GRTWF,1 paddle1_pos_x
INCRF paddle1_pos_x
INCRF paddle1_pos_x
DECRF paddle1_pos_x

LABEL SKIP_PADDLE1_MOVE

// move paddle 2
// first check if ball is going up
MOVFW v_y
EQWL,0 1
GOTO SKIP_PADDLE2_MOVE
// check if its close
MOVFW pos_y
LESSWL,0 PADDLE2_MOVE_RANGE
GOTO SKIP_PADDLE2_MOVE
// check if paddle is already in place
MOVFW pos_x
EQWF,0 paddle2_pos_x
GOTO SKIP_PADDLE2_MOVE

// ball is close, move paddle2
GRTWF,1 paddle2_pos_x
INCRF paddle2_pos_x
INCRF paddle2_pos_x
DECRF paddle2_pos_x

LABEL SKIP_PADDLE2_MOVE

INCRF loop_count
MOVLW MAX_LOOP_COUNT
GRTWF,0 loop_count
GOTO LOOP
GOTO END_GAME

LABEL P1_WIN
CALL draw_p_win_text
IGDRAWRL EVPY(((2 + 10 + 9) << 18) | ((7 + 17) << 12) | ((0 + 10 + 9) << 6) | (17))
GOTO END_GAME

LABEL P2_WIN
CALL draw_p_win_text
IGDRAWRL EVPY(((4 + 10 + 9) << 18) | ((1 + 17) << 12) | ((0 + 10 + 9) << 6) | (17))
IGDRAWRL EVPY(((4 + 10 + 9) << 18) | ((1 + 17 + 3) << 12) | ((0 + 10 + 9) << 6) | (17 + 3))
IGDRAWRL EVPY(((4 + 10 + 9) << 18) | ((1 + 17 + 3 + 3) << 12) | ((0 + 10 + 9) << 6) | (17 + 3 + 3))
GOTO END_GAME

LABEL END_GAME
IGRENDER
// END ------------------------------------------------------------------------

FN draw_p_win_text
//P
IGDRAWRL EVPY(((2 + 10) << 18) | ((7 + 17) << 12) | ((0 + 10) << 6) | (17))
IGDRAWRL EVPY(((2 + 14) << 18) | ((4 + 20) << 12) | ((0 + 14) << 6) | (20))

//W
IGDRAWRL EVPY(((2 + 7) << 18) | ((7 + 7) << 12) | ((0 + 7) << 6) | (7))
IGDRAWRL EVPY(((2 + 7 + 3) << 18) | ((7 + 3) << 12) | ((0 + 7 + 3) << 6) | (7))
IGDRAWRL EVPY(((2 + 7 + 6) << 18) | ((7 + 7) << 12) | ((0 + 7 + 6) << 6) | (7))

//I
IGDRAWRL EVPY(((2 + 7 + 6 + 4) << 18) | ((7 + 7) << 12) | ((0 + 7 + 6 + 4) << 6) | (7))

//N
IGDRAWRL EVPY(((2 + 7 + 6 + 4 + 4) << 18) | ((7 + 7) << 12) | ((0 + 7 + 6 + 4 + 4) << 6) | (7))
IGDRAWRL EVPY(((2 + 7 + 6 + 4 + 4 + 3) << 18) | ((7 + 6) << 12) | ((0 + 7 + 6 + 4 + 4 + 3) << 6) | (7 + 3))
IGDRAWRL EVPY(((2 + 7 + 6 + 4 + 4 + 6) << 18) | ((7 + 7) << 12) | ((0 + 7 + 6 + 4 + 4 + 6) << 6) | (7))
RET

END
